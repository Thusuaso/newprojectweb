{"ast":null,"code":"var AWS = require('../core'),\n  url = AWS.util.url,\n  crypto = AWS.util.crypto.lib,\n  base64Encode = AWS.util.base64.encode,\n  inherit = AWS.util.inherit;\nvar queryEncode = function (string) {\n  var replacements = {\n    '+': '-',\n    '=': '_',\n    '/': '~'\n  };\n  return string.replace(/[\\+=\\/]/g, function (match) {\n    return replacements[match];\n  });\n};\nvar signPolicy = function (policy, privateKey) {\n  var sign = crypto.createSign('RSA-SHA1');\n  sign.write(policy);\n  return queryEncode(sign.sign(privateKey, 'base64'));\n};\nvar signWithCannedPolicy = function (url, expires, keyPairId, privateKey) {\n  var policy = JSON.stringify({\n    Statement: [{\n      Resource: url,\n      Condition: {\n        DateLessThan: {\n          'AWS:EpochTime': expires\n        }\n      }\n    }]\n  });\n  return {\n    Expires: expires,\n    'Key-Pair-Id': keyPairId,\n    Signature: signPolicy(policy.toString(), privateKey)\n  };\n};\nvar signWithCustomPolicy = function (policy, keyPairId, privateKey) {\n  policy = policy.replace(/\\s/mg, '');\n  return {\n    Policy: queryEncode(base64Encode(policy)),\n    'Key-Pair-Id': keyPairId,\n    Signature: signPolicy(policy, privateKey)\n  };\n};\nvar determineScheme = function (url) {\n  var parts = url.split('://');\n  if (parts.length < 2) {\n    throw new Error('Invalid URL.');\n  }\n  return parts[0].replace('*', '');\n};\nvar getRtmpUrl = function (rtmpUrl) {\n  var parsed = url.parse(rtmpUrl);\n  return parsed.path.replace(/^\\//, '') + (parsed.hash || '');\n};\nvar getResource = function (url) {\n  switch (determineScheme(url)) {\n    case 'http':\n    case 'https':\n      return url;\n    case 'rtmp':\n      return getRtmpUrl(url);\n    default:\n      throw new Error('Invalid URI scheme. Scheme must be one of' + ' http, https, or rtmp');\n  }\n};\nvar handleError = function (err, callback) {\n  if (!callback || typeof callback !== 'function') {\n    throw err;\n  }\n  callback(err);\n};\nvar handleSuccess = function (result, callback) {\n  if (!callback || typeof callback !== 'function') {\n    return result;\n  }\n  callback(null, result);\n};\nAWS.CloudFront.Signer = inherit({\n  /**\r\n   * A signer object can be used to generate signed URLs and cookies for granting\r\n   * access to content on restricted CloudFront distributions.\r\n   *\r\n   * @see http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html\r\n   *\r\n   * @param keyPairId [String]    (Required) The ID of the CloudFront key pair\r\n   *                              being used.\r\n   * @param privateKey [String]   (Required) A private key in RSA format.\r\n   */\n  constructor: function Signer(keyPairId, privateKey) {\n    if (keyPairId === void 0 || privateKey === void 0) {\n      throw new Error('A key pair ID and private key are required');\n    }\n    this.keyPairId = keyPairId;\n    this.privateKey = privateKey;\n  },\n  /**\r\n   * Create a signed Amazon CloudFront Cookie.\r\n   *\r\n   * @param options [Object]            The options to create a signed cookie.\r\n   * @option options url [String]     The URL to which the signature will grant\r\n   *                                  access. Required unless you pass in a full\r\n   *                                  policy.\r\n   * @option options expires [Number] A Unix UTC timestamp indicating when the\r\n   *                                  signature should expire. Required unless you\r\n   *                                  pass in a full policy.\r\n   * @option options policy [String]  A CloudFront JSON policy. Required unless\r\n   *                                  you pass in a url and an expiry time.\r\n   *\r\n   * @param cb [Function] if a callback is provided, this function will\r\n   *   pass the hash as the second parameter (after the error parameter) to\r\n   *   the callback function.\r\n   *\r\n   * @return [Object] if called synchronously (with no callback), returns the\r\n   *   signed cookie parameters.\r\n   * @return [null] nothing is returned if a callback is provided.\r\n   */\n  getSignedCookie: function (options, cb) {\n    var signatureHash = 'policy' in options ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey) : signWithCannedPolicy(options.url, options.expires, this.keyPairId, this.privateKey);\n    var cookieHash = {};\n    for (var key in signatureHash) {\n      if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n        cookieHash['CloudFront-' + key] = signatureHash[key];\n      }\n    }\n    return handleSuccess(cookieHash, cb);\n  },\n  /**\r\n   * Create a signed Amazon CloudFront URL.\r\n   *\r\n   * Keep in mind that URLs meant for use in media/flash players may have\r\n   * different requirements for URL formats (e.g. some require that the\r\n   * extension be removed, some require the file name to be prefixed\r\n   * - mp4:<path>, some require you to add \"/cfx/st\" into your URL).\r\n   *\r\n   * @param options [Object]          The options to create a signed URL.\r\n   * @option options url [String]     The URL to which the signature will grant\r\n   *                                  access. Any query params included with\r\n   *                                  the URL should be encoded. Required.\r\n   * @option options expires [Number] A Unix UTC timestamp indicating when the\r\n   *                                  signature should expire. Required unless you\r\n   *                                  pass in a full policy.\r\n   * @option options policy [String]  A CloudFront JSON policy. Required unless\r\n   *                                  you pass in a url and an expiry time.\r\n   *\r\n   * @param cb [Function] if a callback is provided, this function will\r\n   *   pass the URL as the second parameter (after the error parameter) to\r\n   *   the callback function.\r\n   *\r\n   * @return [String] if called synchronously (with no callback), returns the\r\n   *   signed URL.\r\n   * @return [null] nothing is returned if a callback is provided.\r\n   */\n  getSignedUrl: function (options, cb) {\n    try {\n      var resource = getResource(options.url);\n    } catch (err) {\n      return handleError(err, cb);\n    }\n    var parsedUrl = url.parse(options.url, true),\n      signatureHash = Object.prototype.hasOwnProperty.call(options, 'policy') ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey) : signWithCannedPolicy(resource, options.expires, this.keyPairId, this.privateKey);\n    parsedUrl.search = null;\n    for (var key in signatureHash) {\n      if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\n        parsedUrl.query[key] = signatureHash[key];\n      }\n    }\n    try {\n      var signedUrl = determineScheme(options.url) === 'rtmp' ? getRtmpUrl(url.format(parsedUrl)) : url.format(parsedUrl);\n    } catch (err) {\n      return handleError(err, cb);\n    }\n    return handleSuccess(signedUrl, cb);\n  }\n});\n\n/**\r\n * @api private\r\n */\nmodule.exports = AWS.CloudFront.Signer;","map":{"version":3,"names":["AWS","require","url","util","crypto","lib","base64Encode","base64","encode","inherit","queryEncode","string","replacements","replace","match","signPolicy","policy","privateKey","sign","createSign","write","signWithCannedPolicy","expires","keyPairId","JSON","stringify","Statement","Resource","Condition","DateLessThan","Expires","Signature","toString","signWithCustomPolicy","Policy","determineScheme","parts","split","length","Error","getRtmpUrl","rtmpUrl","parsed","parse","path","hash","getResource","handleError","err","callback","handleSuccess","result","CloudFront","Signer","constructor","getSignedCookie","options","cb","signatureHash","cookieHash","key","Object","prototype","hasOwnProperty","call","getSignedUrl","resource","parsedUrl","search","query","signedUrl","format","module","exports"],"sources":["C:/PROJELER/NewProjects/gitPull/newprojectweb/node_modules/aws-sdk/lib/cloudfront/signer.js"],"sourcesContent":["var AWS = require('../core'),\r\n    url = AWS.util.url,\r\n    crypto = AWS.util.crypto.lib,\r\n    base64Encode = AWS.util.base64.encode,\r\n    inherit = AWS.util.inherit;\r\n\r\nvar queryEncode = function (string) {\r\n    var replacements = {\r\n        '+': '-',\r\n        '=': '_',\r\n        '/': '~'\r\n    };\r\n    return string.replace(/[\\+=\\/]/g, function (match) {\r\n        return replacements[match];\r\n    });\r\n};\r\n\r\nvar signPolicy = function (policy, privateKey) {\r\n    var sign = crypto.createSign('RSA-SHA1');\r\n    sign.write(policy);\r\n    return queryEncode(sign.sign(privateKey, 'base64'));\r\n};\r\n\r\nvar signWithCannedPolicy = function (url, expires, keyPairId, privateKey) {\r\n    var policy = JSON.stringify({\r\n        Statement: [\r\n            {\r\n                Resource: url,\r\n                Condition: { DateLessThan: { 'AWS:EpochTime': expires } }\r\n            }\r\n        ]\r\n    });\r\n\r\n    return {\r\n        Expires: expires,\r\n        'Key-Pair-Id': keyPairId,\r\n        Signature: signPolicy(policy.toString(), privateKey)\r\n    };\r\n};\r\n\r\nvar signWithCustomPolicy = function (policy, keyPairId, privateKey) {\r\n    policy = policy.replace(/\\s/mg, '');\r\n\r\n    return {\r\n        Policy: queryEncode(base64Encode(policy)),\r\n        'Key-Pair-Id': keyPairId,\r\n        Signature: signPolicy(policy, privateKey)\r\n    };\r\n};\r\n\r\nvar determineScheme = function (url) {\r\n    var parts = url.split('://');\r\n    if (parts.length < 2) {\r\n        throw new Error('Invalid URL.');\r\n    }\r\n\r\n    return parts[0].replace('*', '');\r\n};\r\n\r\nvar getRtmpUrl = function (rtmpUrl) {\r\n    var parsed = url.parse(rtmpUrl);\r\n    return parsed.path.replace(/^\\//, '') + (parsed.hash || '');\r\n};\r\n\r\nvar getResource = function (url) {\r\n    switch (determineScheme(url)) {\r\n        case 'http':\r\n        case 'https':\r\n            return url;\r\n        case 'rtmp':\r\n            return getRtmpUrl(url);\r\n        default:\r\n            throw new Error('Invalid URI scheme. Scheme must be one of'\r\n                + ' http, https, or rtmp');\r\n    }\r\n};\r\n\r\nvar handleError = function (err, callback) {\r\n    if (!callback || typeof callback !== 'function') {\r\n        throw err;\r\n    }\r\n\r\n    callback(err);\r\n};\r\n\r\nvar handleSuccess = function (result, callback) {\r\n    if (!callback || typeof callback !== 'function') {\r\n        return result;\r\n    }\r\n\r\n    callback(null, result);\r\n};\r\n\r\nAWS.CloudFront.Signer = inherit({\r\n    /**\r\n     * A signer object can be used to generate signed URLs and cookies for granting\r\n     * access to content on restricted CloudFront distributions.\r\n     *\r\n     * @see http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html\r\n     *\r\n     * @param keyPairId [String]    (Required) The ID of the CloudFront key pair\r\n     *                              being used.\r\n     * @param privateKey [String]   (Required) A private key in RSA format.\r\n     */\r\n    constructor: function Signer(keyPairId, privateKey) {\r\n        if (keyPairId === void 0 || privateKey === void 0) {\r\n            throw new Error('A key pair ID and private key are required');\r\n        }\r\n\r\n        this.keyPairId = keyPairId;\r\n        this.privateKey = privateKey;\r\n    },\r\n\r\n    /**\r\n     * Create a signed Amazon CloudFront Cookie.\r\n     *\r\n     * @param options [Object]            The options to create a signed cookie.\r\n     * @option options url [String]     The URL to which the signature will grant\r\n     *                                  access. Required unless you pass in a full\r\n     *                                  policy.\r\n     * @option options expires [Number] A Unix UTC timestamp indicating when the\r\n     *                                  signature should expire. Required unless you\r\n     *                                  pass in a full policy.\r\n     * @option options policy [String]  A CloudFront JSON policy. Required unless\r\n     *                                  you pass in a url and an expiry time.\r\n     *\r\n     * @param cb [Function] if a callback is provided, this function will\r\n     *   pass the hash as the second parameter (after the error parameter) to\r\n     *   the callback function.\r\n     *\r\n     * @return [Object] if called synchronously (with no callback), returns the\r\n     *   signed cookie parameters.\r\n     * @return [null] nothing is returned if a callback is provided.\r\n     */\r\n    getSignedCookie: function (options, cb) {\r\n        var signatureHash = 'policy' in options\r\n            ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey)\r\n            : signWithCannedPolicy(options.url, options.expires, this.keyPairId, this.privateKey);\r\n\r\n        var cookieHash = {};\r\n        for (var key in signatureHash) {\r\n            if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\r\n                cookieHash['CloudFront-' + key] = signatureHash[key];\r\n            }\r\n        }\r\n\r\n        return handleSuccess(cookieHash, cb);\r\n    },\r\n\r\n    /**\r\n     * Create a signed Amazon CloudFront URL.\r\n     *\r\n     * Keep in mind that URLs meant for use in media/flash players may have\r\n     * different requirements for URL formats (e.g. some require that the\r\n     * extension be removed, some require the file name to be prefixed\r\n     * - mp4:<path>, some require you to add \"/cfx/st\" into your URL).\r\n     *\r\n     * @param options [Object]          The options to create a signed URL.\r\n     * @option options url [String]     The URL to which the signature will grant\r\n     *                                  access. Any query params included with\r\n     *                                  the URL should be encoded. Required.\r\n     * @option options expires [Number] A Unix UTC timestamp indicating when the\r\n     *                                  signature should expire. Required unless you\r\n     *                                  pass in a full policy.\r\n     * @option options policy [String]  A CloudFront JSON policy. Required unless\r\n     *                                  you pass in a url and an expiry time.\r\n     *\r\n     * @param cb [Function] if a callback is provided, this function will\r\n     *   pass the URL as the second parameter (after the error parameter) to\r\n     *   the callback function.\r\n     *\r\n     * @return [String] if called synchronously (with no callback), returns the\r\n     *   signed URL.\r\n     * @return [null] nothing is returned if a callback is provided.\r\n     */\r\n    getSignedUrl: function (options, cb) {\r\n        try {\r\n            var resource = getResource(options.url);\r\n        } catch (err) {\r\n            return handleError(err, cb);\r\n        }\r\n\r\n        var parsedUrl = url.parse(options.url, true),\r\n            signatureHash = Object.prototype.hasOwnProperty.call(options, 'policy')\r\n                ? signWithCustomPolicy(options.policy, this.keyPairId, this.privateKey)\r\n                : signWithCannedPolicy(resource, options.expires, this.keyPairId, this.privateKey);\r\n\r\n        parsedUrl.search = null;\r\n        for (var key in signatureHash) {\r\n            if (Object.prototype.hasOwnProperty.call(signatureHash, key)) {\r\n                parsedUrl.query[key] = signatureHash[key];\r\n            }\r\n        }\r\n\r\n        try {\r\n            var signedUrl = determineScheme(options.url) === 'rtmp'\r\n                    ? getRtmpUrl(url.format(parsedUrl))\r\n                    : url.format(parsedUrl);\r\n        } catch (err) {\r\n            return handleError(err, cb);\r\n        }\r\n\r\n        return handleSuccess(signedUrl, cb);\r\n    }\r\n});\r\n\r\n/**\r\n * @api private\r\n */\r\nmodule.exports = AWS.CloudFront.Signer;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}