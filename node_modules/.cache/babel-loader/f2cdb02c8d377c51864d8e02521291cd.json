{"ast":null,"code":"var AWS = require('../core');\n\n/**\r\n * @api private\r\n */\nvar service = null;\n\n/**\r\n * @api private\r\n */\nvar api = {\n  signatureVersion: 'v4',\n  signingName: 'rds-db',\n  operations: {}\n};\n\n/**\r\n * @api private\r\n */\nvar requiredAuthTokenOptions = {\n  region: 'string',\n  hostname: 'string',\n  port: 'number',\n  username: 'string'\n};\n\n/**\r\n * A signer object can be used to generate an auth token to a database.\r\n */\nAWS.RDS.Signer = AWS.util.inherit({\n  /**\r\n   * Creates a signer object can be used to generate an auth token.\r\n   *\r\n   * @option options credentials [AWS.Credentials] the AWS credentials\r\n   *   to sign requests with. Uses the default credential provider chain\r\n   *   if not specified.\r\n   * @option options hostname [String] the hostname of the database to connect to.\r\n   * @option options port [Number] the port number the database is listening on.\r\n   * @option options region [String] the region the database is located in.\r\n   * @option options username [String] the username to login as.\r\n   * @example Passing in options to constructor\r\n   *   var signer = new AWS.RDS.Signer({\r\n   *     credentials: new AWS.SharedIniFileCredentials({profile: 'default'}),\r\n   *     region: 'us-east-1',\r\n   *     hostname: 'db.us-east-1.rds.amazonaws.com',\r\n   *     port: 8000,\r\n   *     username: 'name'\r\n   *   });\r\n   */\n  constructor: function Signer(options) {\n    this.options = options || {};\n  },\n  /**\r\n   * @api private\r\n   * Strips the protocol from a url.\r\n   */\n  convertUrlToAuthToken: function convertUrlToAuthToken(url) {\n    // we are always using https as the protocol\n    var protocol = 'https://';\n    if (url.indexOf(protocol) === 0) {\n      return url.substring(protocol.length);\n    }\n  },\n  /**\r\n   * @overload getAuthToken(options = {}, [callback])\r\n   *   Generate an auth token to a database.\r\n   *   @note You must ensure that you have static or previously resolved\r\n   *     credentials if you call this method synchronously (with no callback),\r\n   *     otherwise it may not properly sign the request. If you cannot guarantee\r\n   *     this (you are using an asynchronous credential provider, i.e., EC2\r\n   *     IAM roles), you should always call this method with an asynchronous\r\n   *     callback.\r\n   *\r\n   *   @param options [map] The fields to use when generating an auth token.\r\n   *     Any options specified here will be merged on top of any options passed\r\n   *     to AWS.RDS.Signer:\r\n   *\r\n   *     * **credentials** (AWS.Credentials) &mdash; the AWS credentials\r\n   *         to sign requests with. Uses the default credential provider chain\r\n   *         if not specified.\r\n   *     * **hostname** (String) &mdash; the hostname of the database to connect to.\r\n   *     * **port** (Number) &mdash; the port number the database is listening on.\r\n   *     * **region** (String) &mdash; the region the database is located in.\r\n   *     * **username** (String) &mdash; the username to login as.\r\n   *   @return [String] if called synchronously (with no callback), returns the\r\n   *     auth token.\r\n   *   @return [null] nothing is returned if a callback is provided.\r\n   *   @callback callback function (err, token)\r\n   *     If a callback is supplied, it is called when an auth token has been generated.\r\n   *     @param err [Error] the error object returned from the signer.\r\n   *     @param token [String] the auth token.\r\n   *\r\n   *   @example Generating an auth token synchronously\r\n   *     var signer = new AWS.RDS.Signer({\r\n   *       // configure options\r\n   *       region: 'us-east-1',\r\n   *       username: 'default',\r\n   *       hostname: 'db.us-east-1.amazonaws.com',\r\n   *       port: 8000\r\n   *     });\r\n   *     var token = signer.getAuthToken({\r\n   *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\r\n   *       // credentials are not specified here or when creating the signer, so default credential provider will be used\r\n   *       username: 'test' // overriding username\r\n   *     });\r\n   *   @example Generating an auth token asynchronously\r\n   *     var signer = new AWS.RDS.Signer({\r\n   *       // configure options\r\n   *       region: 'us-east-1',\r\n   *       username: 'default',\r\n   *       hostname: 'db.us-east-1.amazonaws.com',\r\n   *       port: 8000\r\n   *     });\r\n   *     signer.getAuthToken({\r\n   *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\r\n   *       // credentials are not specified here or when creating the signer, so default credential provider will be used\r\n   *       username: 'test' // overriding username\r\n   *     }, function(err, token) {\r\n   *       if (err) {\r\n   *         // handle error\r\n   *       } else {\r\n   *         // use token\r\n   *       }\r\n   *     });\r\n   *\r\n   */\n  getAuthToken: function getAuthToken(options, callback) {\n    if (typeof options === 'function' && callback === undefined) {\n      callback = options;\n      options = {};\n    }\n    var self = this;\n    var hasCallback = typeof callback === 'function';\n    // merge options with existing options\n    options = AWS.util.merge(this.options, options);\n    // validate options\n    var optionsValidation = this.validateAuthTokenOptions(options);\n    if (optionsValidation !== true) {\n      if (hasCallback) {\n        return callback(optionsValidation, null);\n      }\n      throw optionsValidation;\n    }\n\n    // 15 minutes\n    var expires = 900;\n    // create service to generate a request from\n    var serviceOptions = {\n      region: options.region,\n      endpoint: new AWS.Endpoint(options.hostname + ':' + options.port),\n      paramValidation: false,\n      signatureVersion: 'v4'\n    };\n    if (options.credentials) {\n      serviceOptions.credentials = options.credentials;\n    }\n    service = new AWS.Service(serviceOptions);\n    // ensure the SDK is using sigv4 signing (config is not enough)\n    service.api = api;\n    var request = service.makeRequest();\n    // add listeners to request to properly build auth token\n    this.modifyRequestForAuthToken(request, options);\n    if (hasCallback) {\n      request.presign(expires, function (err, url) {\n        if (url) {\n          url = self.convertUrlToAuthToken(url);\n        }\n        callback(err, url);\n      });\n    } else {\n      var url = request.presign(expires);\n      return this.convertUrlToAuthToken(url);\n    }\n  },\n  /**\r\n   * @api private\r\n   * Modifies a request to allow the presigner to generate an auth token.\r\n   */\n  modifyRequestForAuthToken: function modifyRequestForAuthToken(request, options) {\n    request.on('build', request.buildAsGet);\n    var httpRequest = request.httpRequest;\n    httpRequest.body = AWS.util.queryParamsToString({\n      Action: 'connect',\n      DBUser: options.username\n    });\n  },\n  /**\r\n   * @api private\r\n   * Validates that the options passed in contain all the keys with values of the correct type that\r\n   *   are needed to generate an auth token.\r\n   */\n  validateAuthTokenOptions: function validateAuthTokenOptions(options) {\n    // iterate over all keys in options\n    var message = '';\n    options = options || {};\n    for (var key in requiredAuthTokenOptions) {\n      if (!Object.prototype.hasOwnProperty.call(requiredAuthTokenOptions, key)) {\n        continue;\n      }\n      if (typeof options[key] !== requiredAuthTokenOptions[key]) {\n        message += 'option \\'' + key + '\\' should have been type \\'' + requiredAuthTokenOptions[key] + '\\', was \\'' + typeof options[key] + '\\'.\\n';\n      }\n    }\n    if (message.length) {\n      return AWS.util.error(new Error(), {\n        code: 'InvalidParameter',\n        message: message\n      });\n    }\n    return true;\n  }\n});","map":{"version":3,"names":["AWS","require","service","api","signatureVersion","signingName","operations","requiredAuthTokenOptions","region","hostname","port","username","RDS","Signer","util","inherit","constructor","options","convertUrlToAuthToken","url","protocol","indexOf","substring","length","getAuthToken","callback","undefined","self","hasCallback","merge","optionsValidation","validateAuthTokenOptions","expires","serviceOptions","endpoint","Endpoint","paramValidation","credentials","Service","request","makeRequest","modifyRequestForAuthToken","presign","err","on","buildAsGet","httpRequest","body","queryParamsToString","Action","DBUser","message","key","Object","prototype","hasOwnProperty","call","error","Error","code"],"sources":["C:/PROJELER/NewProjects/gitPull/newprojectweb/node_modules/aws-sdk/lib/rds/signer.js"],"sourcesContent":["var AWS = require('../core');\r\n\r\n/**\r\n * @api private\r\n */\r\nvar service = null;\r\n\r\n/**\r\n * @api private\r\n */\r\nvar api = {\r\n    signatureVersion: 'v4',\r\n    signingName: 'rds-db',\r\n    operations: {}\r\n};\r\n\r\n/**\r\n * @api private\r\n */\r\nvar requiredAuthTokenOptions = {\r\n    region: 'string',\r\n    hostname: 'string',\r\n    port: 'number',\r\n    username: 'string'\r\n};\r\n\r\n/**\r\n * A signer object can be used to generate an auth token to a database.\r\n */\r\nAWS.RDS.Signer = AWS.util.inherit({\r\n    /**\r\n     * Creates a signer object can be used to generate an auth token.\r\n     *\r\n     * @option options credentials [AWS.Credentials] the AWS credentials\r\n     *   to sign requests with. Uses the default credential provider chain\r\n     *   if not specified.\r\n     * @option options hostname [String] the hostname of the database to connect to.\r\n     * @option options port [Number] the port number the database is listening on.\r\n     * @option options region [String] the region the database is located in.\r\n     * @option options username [String] the username to login as.\r\n     * @example Passing in options to constructor\r\n     *   var signer = new AWS.RDS.Signer({\r\n     *     credentials: new AWS.SharedIniFileCredentials({profile: 'default'}),\r\n     *     region: 'us-east-1',\r\n     *     hostname: 'db.us-east-1.rds.amazonaws.com',\r\n     *     port: 8000,\r\n     *     username: 'name'\r\n     *   });\r\n     */\r\n    constructor: function Signer(options) {\r\n        this.options = options || {};\r\n    },\r\n\r\n    /**\r\n     * @api private\r\n     * Strips the protocol from a url.\r\n     */\r\n    convertUrlToAuthToken: function convertUrlToAuthToken(url) {\r\n        // we are always using https as the protocol\r\n        var protocol = 'https://';\r\n        if (url.indexOf(protocol) === 0) {\r\n            return url.substring(protocol.length);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @overload getAuthToken(options = {}, [callback])\r\n     *   Generate an auth token to a database.\r\n     *   @note You must ensure that you have static or previously resolved\r\n     *     credentials if you call this method synchronously (with no callback),\r\n     *     otherwise it may not properly sign the request. If you cannot guarantee\r\n     *     this (you are using an asynchronous credential provider, i.e., EC2\r\n     *     IAM roles), you should always call this method with an asynchronous\r\n     *     callback.\r\n     *\r\n     *   @param options [map] The fields to use when generating an auth token.\r\n     *     Any options specified here will be merged on top of any options passed\r\n     *     to AWS.RDS.Signer:\r\n     *\r\n     *     * **credentials** (AWS.Credentials) &mdash; the AWS credentials\r\n     *         to sign requests with. Uses the default credential provider chain\r\n     *         if not specified.\r\n     *     * **hostname** (String) &mdash; the hostname of the database to connect to.\r\n     *     * **port** (Number) &mdash; the port number the database is listening on.\r\n     *     * **region** (String) &mdash; the region the database is located in.\r\n     *     * **username** (String) &mdash; the username to login as.\r\n     *   @return [String] if called synchronously (with no callback), returns the\r\n     *     auth token.\r\n     *   @return [null] nothing is returned if a callback is provided.\r\n     *   @callback callback function (err, token)\r\n     *     If a callback is supplied, it is called when an auth token has been generated.\r\n     *     @param err [Error] the error object returned from the signer.\r\n     *     @param token [String] the auth token.\r\n     *\r\n     *   @example Generating an auth token synchronously\r\n     *     var signer = new AWS.RDS.Signer({\r\n     *       // configure options\r\n     *       region: 'us-east-1',\r\n     *       username: 'default',\r\n     *       hostname: 'db.us-east-1.amazonaws.com',\r\n     *       port: 8000\r\n     *     });\r\n     *     var token = signer.getAuthToken({\r\n     *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\r\n     *       // credentials are not specified here or when creating the signer, so default credential provider will be used\r\n     *       username: 'test' // overriding username\r\n     *     });\r\n     *   @example Generating an auth token asynchronously\r\n     *     var signer = new AWS.RDS.Signer({\r\n     *       // configure options\r\n     *       region: 'us-east-1',\r\n     *       username: 'default',\r\n     *       hostname: 'db.us-east-1.amazonaws.com',\r\n     *       port: 8000\r\n     *     });\r\n     *     signer.getAuthToken({\r\n     *       // these options are merged with those defined when creating the signer, overriding in the case of a duplicate option\r\n     *       // credentials are not specified here or when creating the signer, so default credential provider will be used\r\n     *       username: 'test' // overriding username\r\n     *     }, function(err, token) {\r\n     *       if (err) {\r\n     *         // handle error\r\n     *       } else {\r\n     *         // use token\r\n     *       }\r\n     *     });\r\n     *\r\n     */\r\n    getAuthToken: function getAuthToken(options, callback) {\r\n        if (typeof options === 'function' && callback === undefined) {\r\n            callback = options;\r\n            options = {};\r\n        }\r\n        var self = this;\r\n        var hasCallback = typeof callback === 'function';\r\n        // merge options with existing options\r\n        options = AWS.util.merge(this.options, options);\r\n        // validate options\r\n        var optionsValidation = this.validateAuthTokenOptions(options);\r\n        if (optionsValidation !== true) {\r\n            if (hasCallback) {\r\n                return callback(optionsValidation, null);\r\n            }\r\n            throw optionsValidation;\r\n        }\r\n\r\n        // 15 minutes\r\n        var expires = 900;\r\n        // create service to generate a request from\r\n        var serviceOptions = {\r\n            region: options.region,\r\n            endpoint: new AWS.Endpoint(options.hostname + ':' + options.port),\r\n            paramValidation: false,\r\n            signatureVersion: 'v4'\r\n        };\r\n        if (options.credentials) {\r\n            serviceOptions.credentials = options.credentials;\r\n        }\r\n        service = new AWS.Service(serviceOptions);\r\n        // ensure the SDK is using sigv4 signing (config is not enough)\r\n        service.api = api;\r\n\r\n        var request = service.makeRequest();\r\n        // add listeners to request to properly build auth token\r\n        this.modifyRequestForAuthToken(request, options);\r\n\r\n        if (hasCallback) {\r\n            request.presign(expires, function(err, url) {\r\n                if (url) {\r\n                    url = self.convertUrlToAuthToken(url);\r\n                }\r\n                callback(err, url);\r\n            });\r\n        } else {\r\n            var url = request.presign(expires);\r\n            return this.convertUrlToAuthToken(url);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @api private\r\n     * Modifies a request to allow the presigner to generate an auth token.\r\n     */\r\n    modifyRequestForAuthToken: function modifyRequestForAuthToken(request, options) {\r\n        request.on('build', request.buildAsGet);\r\n        var httpRequest = request.httpRequest;\r\n        httpRequest.body = AWS.util.queryParamsToString({\r\n            Action: 'connect',\r\n            DBUser: options.username\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @api private\r\n     * Validates that the options passed in contain all the keys with values of the correct type that\r\n     *   are needed to generate an auth token.\r\n     */\r\n    validateAuthTokenOptions: function validateAuthTokenOptions(options) {\r\n        // iterate over all keys in options\r\n        var message = '';\r\n        options = options || {};\r\n        for (var key in requiredAuthTokenOptions) {\r\n            if (!Object.prototype.hasOwnProperty.call(requiredAuthTokenOptions, key)) {\r\n                continue;\r\n            }\r\n            if (typeof options[key] !== requiredAuthTokenOptions[key]) {\r\n                message += 'option \\'' + key + '\\' should have been type \\'' + requiredAuthTokenOptions[key] + '\\', was \\'' + typeof options[key] + '\\'.\\n';\r\n            }\r\n        }\r\n        if (message.length) {\r\n            return AWS.util.error(new Error(), {\r\n                code: 'InvalidParameter',\r\n                message: message\r\n            });\r\n        }\r\n        return true;\r\n    }\r\n});\r\n"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,SAAS,CAAC;;AAE5B;AACA;AACA;AACA,IAAIC,OAAO,GAAG,IAAI;;AAElB;AACA;AACA;AACA,IAAIC,GAAG,GAAG;EACNC,gBAAgB,EAAE,IAAI;EACtBC,WAAW,EAAE,QAAQ;EACrBC,UAAU,EAAE,CAAC;AACjB,CAAC;;AAED;AACA;AACA;AACA,IAAIC,wBAAwB,GAAG;EAC3BC,MAAM,EAAE,QAAQ;EAChBC,QAAQ,EAAE,QAAQ;EAClBC,IAAI,EAAE,QAAQ;EACdC,QAAQ,EAAE;AACd,CAAC;;AAED;AACA;AACA;AACAX,GAAG,CAACY,GAAG,CAACC,MAAM,GAAGb,GAAG,CAACc,IAAI,CAACC,OAAO,CAAC;EAC9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,WAAW,EAAE,SAASH,MAAM,CAACI,OAAO,EAAE;IAClC,IAAI,CAACA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAChC,CAAC;EAED;AACJ;AACA;AACA;EACIC,qBAAqB,EAAE,SAASA,qBAAqB,CAACC,GAAG,EAAE;IACvD;IACA,IAAIC,QAAQ,GAAG,UAAU;IACzB,IAAID,GAAG,CAACE,OAAO,CAACD,QAAQ,CAAC,KAAK,CAAC,EAAE;MAC7B,OAAOD,GAAG,CAACG,SAAS,CAACF,QAAQ,CAACG,MAAM,CAAC;IACzC;EACJ,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAY,EAAE,SAASA,YAAY,CAACP,OAAO,E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"},"metadata":{},"sourceType":"script"}