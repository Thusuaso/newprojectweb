{"ast":null,"code":"require(\"core-js/modules/es.array.unshift.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nvar AWS = require('./core');\n\n/**\r\n * @api private\r\n * @!method on(eventName, callback)\r\n *   Registers an event listener callback for the event given by `eventName`.\r\n *   Parameters passed to the callback function depend on the individual event\r\n *   being triggered. See the event documentation for those parameters.\r\n *\r\n *   @param eventName [String] the event name to register the listener for\r\n *   @param callback [Function] the listener callback function\r\n *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.\r\n *     Default to be false.\r\n *   @return [AWS.SequentialExecutor] the same object for chaining\r\n */\nAWS.SequentialExecutor = AWS.util.inherit({\n  constructor: function SequentialExecutor() {\n    this._events = {};\n  },\n  /**\r\n   * @api private\r\n   */\n  listeners: function listeners(eventName) {\n    return this._events[eventName] ? this._events[eventName].slice(0) : [];\n  },\n  on: function on(eventName, listener, toHead) {\n    if (this._events[eventName]) {\n      toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);\n    } else {\n      this._events[eventName] = [listener];\n    }\n    return this;\n  },\n  onAsync: function onAsync(eventName, listener, toHead) {\n    listener._isAsync = true;\n    return this.on(eventName, listener, toHead);\n  },\n  removeListener: function removeListener(eventName, listener) {\n    var listeners = this._events[eventName];\n    if (listeners) {\n      var length = listeners.length;\n      var position = -1;\n      for (var i = 0; i < length; ++i) {\n        if (listeners[i] === listener) {\n          position = i;\n        }\n      }\n      if (position > -1) {\n        listeners.splice(position, 1);\n      }\n    }\n    return this;\n  },\n  removeAllListeners: function removeAllListeners(eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n    return this;\n  },\n  /**\r\n   * @api private\r\n   */\n  emit: function emit(eventName, eventArgs, doneCallback) {\n    if (!doneCallback) doneCallback = function () {};\n    var listeners = this.listeners(eventName);\n    var count = listeners.length;\n    this.callListeners(listeners, eventArgs, doneCallback);\n    return count > 0;\n  },\n  /**\r\n   * @api private\r\n   */\n  callListeners: function callListeners(listeners, args, doneCallback, prevError) {\n    var self = this;\n    var error = prevError || null;\n    function callNextListener(err) {\n      if (err) {\n        error = AWS.util.error(error || new Error(), err);\n        if (self._haltHandlersOnError) {\n          return doneCallback.call(self, error);\n        }\n      }\n      self.callListeners(listeners, args, doneCallback, error);\n    }\n    while (listeners.length > 0) {\n      var listener = listeners.shift();\n      if (listener._isAsync) {\n        // asynchronous listener\n        listener.apply(self, args.concat([callNextListener]));\n        return; // stop here, callNextListener will continue\n      } else {\n        // synchronous listener\n        try {\n          listener.apply(self, args);\n        } catch (err) {\n          error = AWS.util.error(error || new Error(), err);\n        }\n        if (error && self._haltHandlersOnError) {\n          doneCallback.call(self, error);\n          return;\n        }\n      }\n    }\n    doneCallback.call(self, error);\n  },\n  /**\r\n   * Adds or copies a set of listeners from another list of\r\n   * listeners or SequentialExecutor object.\r\n   *\r\n   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]\r\n   *   a list of events and callbacks, or an event emitter object\r\n   *   containing listeners to add to this emitter object.\r\n   * @return [AWS.SequentialExecutor] the emitter object, for chaining.\r\n   * @example Adding listeners from a map of listeners\r\n   *   emitter.addListeners({\r\n   *     event1: [function() { ... }, function() { ... }],\r\n   *     event2: [function() { ... }]\r\n   *   });\r\n   *   emitter.emit('event1'); // emitter has event1\r\n   *   emitter.emit('event2'); // emitter has event2\r\n   * @example Adding listeners from another emitter object\r\n   *   var emitter1 = new AWS.SequentialExecutor();\r\n   *   emitter1.on('event1', function() { ... });\r\n   *   emitter1.on('event2', function() { ... });\r\n   *   var emitter2 = new AWS.SequentialExecutor();\r\n   *   emitter2.addListeners(emitter1);\r\n   *   emitter2.emit('event1'); // emitter2 has event1\r\n   *   emitter2.emit('event2'); // emitter2 has event2\r\n   */\n  addListeners: function addListeners(listeners) {\n    var self = this;\n\n    // extract listeners if parameter is an SequentialExecutor object\n    if (listeners._events) listeners = listeners._events;\n    AWS.util.each(listeners, function (event, callbacks) {\n      if (typeof callbacks === 'function') callbacks = [callbacks];\n      AWS.util.arrayEach(callbacks, function (callback) {\n        self.on(event, callback);\n      });\n    });\n    return self;\n  },\n  /**\r\n   * Registers an event with {on} and saves the callback handle function\r\n   * as a property on the emitter object using a given `name`.\r\n   *\r\n   * @param name [String] the property name to set on this object containing\r\n   *   the callback function handle so that the listener can be removed in\r\n   *   the future.\r\n   * @param (see on)\r\n   * @return (see on)\r\n   * @example Adding a named listener DATA_CALLBACK\r\n   *   var listener = function() { doSomething(); };\r\n   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);\r\n   *\r\n   *   // the following prints: true\r\n   *   console.log(emitter.DATA_CALLBACK == listener);\r\n   */\n  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {\n    this[name] = callback;\n    this.addListener(eventName, callback, toHead);\n    return this;\n  },\n  /**\r\n   * @api private\r\n   */\n  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {\n    callback._isAsync = true;\n    return this.addNamedListener(name, eventName, callback, toHead);\n  },\n  /**\r\n   * Helper method to add a set of named listeners using\r\n   * {addNamedListener}. The callback contains a parameter\r\n   * with a handle to the `addNamedListener` method.\r\n   *\r\n   * @callback callback function(add)\r\n   *   The callback function is called immediately in order to provide\r\n   *   the `add` function to the block. This simplifies the addition of\r\n   *   a large group of named listeners.\r\n   *   @param add [Function] the {addNamedListener} function to call\r\n   *     when registering listeners.\r\n   * @example Adding a set of named listeners\r\n   *   emitter.addNamedListeners(function(add) {\r\n   *     add('DATA_CALLBACK', 'data', function() { ... });\r\n   *     add('OTHER', 'otherEvent', function() { ... });\r\n   *     add('LAST', 'lastEvent', function() { ... });\r\n   *   });\r\n   *\r\n   *   // these properties are now set:\r\n   *   emitter.DATA_CALLBACK;\r\n   *   emitter.OTHER;\r\n   *   emitter.LAST;\r\n   */\n  addNamedListeners: function addNamedListeners(callback) {\n    var self = this;\n    callback(function () {\n      self.addNamedListener.apply(self, arguments);\n    }, function () {\n      self.addNamedAsyncListener.apply(self, arguments);\n    });\n    return this;\n  }\n});\n\n/**\r\n * {on} is the prefered method.\r\n * @api private\r\n */\nAWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;\n\n/**\r\n * @api private\r\n */\nmodule.exports = AWS.SequentialExecutor;","map":{"version":3,"names":["AWS","require","SequentialExecutor","util","inherit","constructor","_events","listeners","eventName","slice","on","listener","toHead","unshift","push","onAsync","_isAsync","removeListener","length","position","i","splice","removeAllListeners","emit","eventArgs","doneCallback","count","callListeners","args","prevError","self","error","callNextListener","err","Error","_haltHandlersOnError","call","shift","apply","concat","addListeners","each","event","callbacks","arrayEach","callback","addNamedListener","name","addListener","addNamedAsyncListener","addNamedListeners","arguments","prototype","module","exports"],"sources":["C:/PROJELER/NewProjects/gitPull/newprojectweb/node_modules/aws-sdk/lib/sequential_executor.js"],"sourcesContent":["var AWS = require('./core');\r\n\r\n/**\r\n * @api private\r\n * @!method on(eventName, callback)\r\n *   Registers an event listener callback for the event given by `eventName`.\r\n *   Parameters passed to the callback function depend on the individual event\r\n *   being triggered. See the event documentation for those parameters.\r\n *\r\n *   @param eventName [String] the event name to register the listener for\r\n *   @param callback [Function] the listener callback function\r\n *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.\r\n *     Default to be false.\r\n *   @return [AWS.SequentialExecutor] the same object for chaining\r\n */\r\nAWS.SequentialExecutor = AWS.util.inherit({\r\n\r\n  constructor: function SequentialExecutor() {\r\n    this._events = {};\r\n  },\r\n\r\n  /**\r\n   * @api private\r\n   */\r\n  listeners: function listeners(eventName) {\r\n    return this._events[eventName] ? this._events[eventName].slice(0) : [];\r\n  },\r\n\r\n  on: function on(eventName, listener, toHead) {\r\n    if (this._events[eventName]) {\r\n      toHead ?\r\n        this._events[eventName].unshift(listener) :\r\n        this._events[eventName].push(listener);\r\n    } else {\r\n      this._events[eventName] = [listener];\r\n    }\r\n    return this;\r\n  },\r\n\r\n  onAsync: function onAsync(eventName, listener, toHead) {\r\n    listener._isAsync = true;\r\n    return this.on(eventName, listener, toHead);\r\n  },\r\n\r\n  removeListener: function removeListener(eventName, listener) {\r\n    var listeners = this._events[eventName];\r\n    if (listeners) {\r\n      var length = listeners.length;\r\n      var position = -1;\r\n      for (var i = 0; i < length; ++i) {\r\n        if (listeners[i] === listener) {\r\n          position = i;\r\n        }\r\n      }\r\n      if (position > -1) {\r\n        listeners.splice(position, 1);\r\n      }\r\n    }\r\n    return this;\r\n  },\r\n\r\n  removeAllListeners: function removeAllListeners(eventName) {\r\n    if (eventName) {\r\n      delete this._events[eventName];\r\n    } else {\r\n      this._events = {};\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @api private\r\n   */\r\n  emit: function emit(eventName, eventArgs, doneCallback) {\r\n    if (!doneCallback) doneCallback = function() { };\r\n    var listeners = this.listeners(eventName);\r\n    var count = listeners.length;\r\n    this.callListeners(listeners, eventArgs, doneCallback);\r\n    return count > 0;\r\n  },\r\n\r\n  /**\r\n   * @api private\r\n   */\r\n  callListeners: function callListeners(listeners, args, doneCallback, prevError) {\r\n    var self = this;\r\n    var error = prevError || null;\r\n\r\n    function callNextListener(err) {\r\n      if (err) {\r\n        error = AWS.util.error(error || new Error(), err);\r\n        if (self._haltHandlersOnError) {\r\n          return doneCallback.call(self, error);\r\n        }\r\n      }\r\n      self.callListeners(listeners, args, doneCallback, error);\r\n    }\r\n\r\n    while (listeners.length > 0) {\r\n      var listener = listeners.shift();\r\n      if (listener._isAsync) { // asynchronous listener\r\n        listener.apply(self, args.concat([callNextListener]));\r\n        return; // stop here, callNextListener will continue\r\n      } else { // synchronous listener\r\n        try {\r\n          listener.apply(self, args);\r\n        } catch (err) {\r\n          error = AWS.util.error(error || new Error(), err);\r\n        }\r\n        if (error && self._haltHandlersOnError) {\r\n          doneCallback.call(self, error);\r\n          return;\r\n        }\r\n      }\r\n    }\r\n    doneCallback.call(self, error);\r\n  },\r\n\r\n  /**\r\n   * Adds or copies a set of listeners from another list of\r\n   * listeners or SequentialExecutor object.\r\n   *\r\n   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]\r\n   *   a list of events and callbacks, or an event emitter object\r\n   *   containing listeners to add to this emitter object.\r\n   * @return [AWS.SequentialExecutor] the emitter object, for chaining.\r\n   * @example Adding listeners from a map of listeners\r\n   *   emitter.addListeners({\r\n   *     event1: [function() { ... }, function() { ... }],\r\n   *     event2: [function() { ... }]\r\n   *   });\r\n   *   emitter.emit('event1'); // emitter has event1\r\n   *   emitter.emit('event2'); // emitter has event2\r\n   * @example Adding listeners from another emitter object\r\n   *   var emitter1 = new AWS.SequentialExecutor();\r\n   *   emitter1.on('event1', function() { ... });\r\n   *   emitter1.on('event2', function() { ... });\r\n   *   var emitter2 = new AWS.SequentialExecutor();\r\n   *   emitter2.addListeners(emitter1);\r\n   *   emitter2.emit('event1'); // emitter2 has event1\r\n   *   emitter2.emit('event2'); // emitter2 has event2\r\n   */\r\n  addListeners: function addListeners(listeners) {\r\n    var self = this;\r\n\r\n    // extract listeners if parameter is an SequentialExecutor object\r\n    if (listeners._events) listeners = listeners._events;\r\n\r\n    AWS.util.each(listeners, function(event, callbacks) {\r\n      if (typeof callbacks === 'function') callbacks = [callbacks];\r\n      AWS.util.arrayEach(callbacks, function(callback) {\r\n        self.on(event, callback);\r\n      });\r\n    });\r\n\r\n    return self;\r\n  },\r\n\r\n  /**\r\n   * Registers an event with {on} and saves the callback handle function\r\n   * as a property on the emitter object using a given `name`.\r\n   *\r\n   * @param name [String] the property name to set on this object containing\r\n   *   the callback function handle so that the listener can be removed in\r\n   *   the future.\r\n   * @param (see on)\r\n   * @return (see on)\r\n   * @example Adding a named listener DATA_CALLBACK\r\n   *   var listener = function() { doSomething(); };\r\n   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);\r\n   *\r\n   *   // the following prints: true\r\n   *   console.log(emitter.DATA_CALLBACK == listener);\r\n   */\r\n  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {\r\n    this[name] = callback;\r\n    this.addListener(eventName, callback, toHead);\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @api private\r\n   */\r\n  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {\r\n    callback._isAsync = true;\r\n    return this.addNamedListener(name, eventName, callback, toHead);\r\n  },\r\n\r\n  /**\r\n   * Helper method to add a set of named listeners using\r\n   * {addNamedListener}. The callback contains a parameter\r\n   * with a handle to the `addNamedListener` method.\r\n   *\r\n   * @callback callback function(add)\r\n   *   The callback function is called immediately in order to provide\r\n   *   the `add` function to the block. This simplifies the addition of\r\n   *   a large group of named listeners.\r\n   *   @param add [Function] the {addNamedListener} function to call\r\n   *     when registering listeners.\r\n   * @example Adding a set of named listeners\r\n   *   emitter.addNamedListeners(function(add) {\r\n   *     add('DATA_CALLBACK', 'data', function() { ... });\r\n   *     add('OTHER', 'otherEvent', function() { ... });\r\n   *     add('LAST', 'lastEvent', function() { ... });\r\n   *   });\r\n   *\r\n   *   // these properties are now set:\r\n   *   emitter.DATA_CALLBACK;\r\n   *   emitter.OTHER;\r\n   *   emitter.LAST;\r\n   */\r\n  addNamedListeners: function addNamedListeners(callback) {\r\n    var self = this;\r\n    callback(\r\n      function() {\r\n        self.addNamedListener.apply(self, arguments);\r\n      },\r\n      function() {\r\n        self.addNamedAsyncListener.apply(self, arguments);\r\n      }\r\n    );\r\n    return this;\r\n  }\r\n});\r\n\r\n/**\r\n * {on} is the prefered method.\r\n * @api private\r\n */\r\nAWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;\r\n\r\n/**\r\n * @api private\r\n */\r\nmodule.exports = AWS.SequentialExecutor;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}